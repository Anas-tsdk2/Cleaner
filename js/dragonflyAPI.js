class DragonflyAPI {
    constructor() {
        this.baseUrl = 'https://ai.dragonflygroup.fr/api/v1';
        this.assistantId = 'asst_1f1UeJGMURpenLfrj4Aaykyp';
    }

    setAssistantId(id) {
        console.log("üîß Changement d'assistant ID:", id);
        this.assistantId = id;
    }

    async validateToken(token) {
        console.log("üîë Validation du token...");
        try {
            const response = await fetch(`${this.baseUrl}/user/assistants`, {
                method: 'GET',
                headers: {
                    'Authorization': `Bearer ${token}`
                }
            });
            const isValid = response.ok;
            console.log(isValid ? "‚úÖ Token valide" : "‚ùå Token invalide");
            return isValid;
        } catch (error) {
            console.error("‚ùå Erreur validation token:", error);
            return false;
        }
    }

    async getAssistants() {
        console.log("üìã R√©cup√©ration des assistants");
        const token = TokenManager.get();
        if (!token) throw new Error('Token manquant');

        const response = await fetch(`${this.baseUrl}/user/assistants`, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${token}`
            }
        });

        if (!response.ok) throw new Error('Erreur r√©cup√©ration assistants');
        return await response.json();
    }

    async processFullRow(row, headers) {
        try {
            console.log("üöÄ D√©but traitement ligne:", row);
            const context = this.buildRowContext(row, headers);
            
            const prompt = this.buildFullRowPrompt(context);
            
            const response = await this.processRow({
                prompt: prompt,
                fullRow: row
            });
            console.log("‚ú® R√©ponse API brute:", response);
    
            if (!response || !response.choices || !response.choices[0]) {
                throw new Error('R√©ponse API invalide');
            }
    
            const result = await this.parseFullRowResponse(response);
            console.log("‚úÖ R√©sultat final:", result);
            return result;
        } catch (error) {
            console.error("‚ùå Erreur dans processFullRow:", error);
            console.error("D√©tails de l'erreur:", {
                message: error.message,
                stack: error.stack
            });
            return this.generateErrorResponse(row, headers);
        }
    }

    buildRowContext(row, headers) {
        const context = {};
        headers.forEach((header, index) => {
            context[this.normalizeHeader(header)] = row[index] || '';
        });
        return context;
    }

    normalizeHeader(header) {
        return header
            .toLowerCase()
            .normalize('NFD')
            .replace(/[\u0300-\u036f]/g, '')
            .replace(/[^a-z0-9]/g, '_');
    }

    buildFullRowPrompt(context) {
        return `
**Nettoyage & Normalisation de Donn√©es CSV**

* **Entr√©e** : ${JSON.stringify(context, null, 2)}

* **R√®gles de Traitement Sp√©cifiques (appliqu√©es automatiquement)** :
	### a. Civilit√© (Title)
	+ Normaliser √† "Madame" pour pr√©nom f√©minin et "Monsieur" pour pr√©nom masculin
	+ V√©rification crois√©e avec : pr√©fixe E-mail, Nom complet, indicateurs de genre dans tous les champs

	### b. Pr√©nom (First Name)
	+ Mettre en majuscule la premi√®re lettre
	+ Supprimer les espaces suppl√©mentaires
	+ Corriger les erreurs d'orthographe √©videntes
	+ Si vide, essayer de reconstruire √† partir du Nom complet ou de l'E-mail

	### c. Nom (Last Name)
	+ Mettre en majuscule la premi√®re lettre
	+ Supprimer les espaces suppl√©mentaires
	+ Corriger les erreurs d'orthographe √©videntes
	+ Si vide, essayer de reconstruire √† partir du Nom complet ou de l'E-mail

	### d. Nom Complet (Full Name)
	+ S'assurer qu'il correspond √† la combinaison de Pr√©nom et Nom
	+ Formatter comme "Pr√©nom Nom"
	+ Si vide, reconstruire √† partir de Pr√©nom et Nom, ou √† partir de l'E-mail si possible

	### e. Fonction (Job Title)
	+ Mettre en majuscule la premi√®re lettre de chaque mot
	+ Standardiser les titres courants (ex : "Directeur" au lieu de "Dir.")
	+ Supprimer les d√©tails inutiles ou les duplications
	+ Supprimer tout texte entre parenth√®ses, y compris les parenth√®ses

	### f. E-mail
	+ S'assurer que c'est un format d'e-mail valide
	+ Corriger les erreurs de domaine √©videntes (ex : absence de .com ou .fr)

	### g. Organisation
	+ Mettre en majuscule la premi√®re lettre de chaque mot
	+ Supprimer les espaces suppl√©mentaires
	+ Corriger les erreurs d'orthographe √©videntes

	### h. Num√©ro de T√©l√©phone
	+ Standardiser au format : 00 00 00 00 00
	+ Supprimer les caract√®res non num√©riques
	+ S'assurer qu'il s'agit d'un num√©ro de t√©l√©phone fran√ßais valide (10 chiffres)

**T√¢che** :
	1. Traitez l'exemple de donn√©es d'entr√©e ci-dessus en appliquant les r√®gles sp√©cifiques.
    2. Ne pas inclure de remarques, d'explications ou de textes suppl√©mentaires dans la r√©ponse. Seul le JSON de sortie est requis.**
	3. **R√©ponse attendue : UNIQUEMENT le JSON de Sortie r√©sultant (ex√©cutable par script)**  :

[
  {"field": "Civility", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "FirstName", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "LastName", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "FullName", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "JobTitle", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "Email", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "Organization", "value": "...", "confidence": ..., "notes": "..."},
  {"field": "PhoneNumber", "value": "...", "confidence": ..., "notes": "..."}
]
`;
    }

    async readStream(reader) {
        let result = '';
        const decoder = new TextDecoder();
        console.log("üìñ D√©but lecture stream");

        try {
            while (true) {
                const { value, done } = await reader.read();
                if (done) {
                    console.log("‚úÖ Fin lecture stream");
                    break;
                }

                const chunk = decoder.decode(value);

                const lines = chunk.split('\n');
                for (const line of lines) {
                    if (line.trim().startsWith('data:')) {
                        const jsonStr = line.replace('data:', '').trim();
                        if (jsonStr === '[DONE]') continue;

                        try {
                            const parsed = JSON.parse(jsonStr);
                            if (parsed.choices?.[0]?.delta?.content) {
                                result += parsed.choices[0].delta.content;
                            } else if (parsed.choices?.[0]?.message?.content) {
                                result += parsed.choices[0].message.content;
                            }
                        } catch (e) {
                            if (jsonStr.trim()) {
                                console.debug('‚ö†Ô∏è Chunk non parsable:', jsonStr);
                            }
                        }
                    }
                }
            }
        } catch (error) {
            console.error("‚ùå Erreur lecture stream:", error);
        }

        console.log("üéØ R√©sultat stream complet:", result);
        return result.trim();
    }

    async processRow(rowData) {
        console.log("üîÑ Traitement row:", rowData);
        const token = TokenManager.get();
        if (!token) throw new Error('Token manquant');

        const response = await fetch(`${this.baseUrl}/chat/completions`, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${token}`,
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                messages: [{
                    role: "user",
                    content: [{
                        type: "text",
                        text: rowData.prompt
                    }]
                }],
                assistantId: this.assistantId,
                temperature: 1,
                stream: true
            })
        });

        if (!response.ok) {
            const error = await response.json().catch(() => ({}));
            throw new Error(`Erreur API: ${response.status} ${error.message || ''}`);
        }

        const reader = response.body.getReader();
        const result = await this.readStream(reader);

        return {
            choices: [{
                message: {
                    content: result
                }
            }]
        };
    }

   
    async parseFullRowResponse(response) {
        console.log("üîç D√©but parseFullRowResponse avec:", response);
        
        try {
            // √âtape 1 : Extraire les donn√©es du format de r√©ponse
            let cleanedData;
            
            if (Array.isArray(response)) {
                cleanedData = response;
            } else if (typeof response === 'string') {
                cleanedData = JSON.parse(response);
            } else if (response && response.choices && response.choices[0]?.message?.content) {
                // Nouveau cas : extraire le contenu du message
                const content = response.choices[0].message.content;
                console.log("üìù Contenu brut extrait:", content);
                
                // Nettoyer le contenu avant le parsing
                const cleanContent = content
                    .replace(/[\u0000-\u001F\u007F-\u009F]/g, "") // Supprimer les caract√®res de contr√¥le
                    .replace(/'/g, "'") // Remplacer les apostrophes courbes par des droites
                    .replace(/`/g, "'") // Remplacer les backticks par des apostrophes
                    .replace(/[\u2018\u2019]/g, "'") // Remplacer les guillemets simples typographiques
                    .replace(/[\u201C\u201D]/g, '"'); // Remplacer les guillemets doubles typographiques
                
                console.log("üßπ Contenu nettoy√©:", cleanContent);
                
                try {
                    cleanedData = JSON.parse(cleanContent);
                } catch (parseError) {
                    console.error("‚ùå Erreur parsing JSON initial:", parseError);
                    // Tentative de r√©cup√©ration en retirant les caract√®res probl√©matiques
                    const sanitizedContent = cleanContent.replace(/[^\x20-\x7E]/g, "");
                    cleanedData = JSON.parse(sanitizedContent);
                }
            } else if (response && Array.isArray(response.cleanedData)) {
                cleanedData = response.cleanedData;
            } else {
                throw new Error("Format de donn√©es invalide");
            }
            
            console.log("üì• Donn√©es brutes r√©cup√©r√©es:", cleanedData);
    
            // √âtape 2 : Normalisation des donn√©es
            cleanedData = cleanedData.map(item => {
                // V√©rifier que l'item est un objet valide
                if (!item || typeof item !== 'object') {
                    console.warn("‚ö†Ô∏è Item invalide d√©tect√©:", item);
                    return null;
                }
    
                // Normalisation de la confiance
                let confidence;
                if (typeof item.confidence === 'string') {
                    // G√©rer les cas comme "100%" ou "0.8"
                    confidence = parseFloat(item.confidence.replace('%', '')) / 
                        (item.confidence.includes('%') ? 100 : 1);
                } else if (typeof item.confidence === 'number') {
                    confidence = item.confidence;
                } else {
                    confidence = 0;
                    console.warn("‚ö†Ô∏è Confiance invalide pour:", item);
                }
    
                // S'assurer que la confiance est entre 0 et 1
                confidence = Math.max(0, Math.min(1, confidence));
    
                return {
                    field: item.field || '',
                    value: item.value || '',
                    confidence: confidence,
                    notes: item.notes || ''
                };
            }).filter(item => item !== null);
    
            console.log("‚ú® Donn√©es normalis√©es:", cleanedData);
    
            return {
                success: true,
                cleanedData: cleanedData,
                analysis: ''
            };
    
        } catch (error) {
            console.error("‚ùå Erreur dans parseFullRowResponse:", error);
            console.error("üìÑ Donn√©es probl√©matiques:", response);
            return {
                success: false,
                cleanedData: [],
                analysis: error.message
            };
        }
    }
    
    generateErrorResponse(row, headers) {
        return {
            success: false,
            headers:data.map((header, index) => ({
                field: header,
                value: row[index] || '',
                confidence: 0,
                notes: "Erreur de traitement"
            }))
        };
    }

    isValidEmail(value) {
        const emailRegex = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
        return emailRegex.test(value);
    }

    isValidPhone(value) {
        const phoneRegex = /^(\d{2}\s){4}\d{2}$/;
        return phoneRegex.test(value);
    }

    formatPhone(value) {
        const digits = value.replace(/\D/g, '');
        if (digits.length !== 10) return '-';
        return digits.replace(/(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})/, '$1 $2 $3 $4 $5');
    }
}

window.dragonflyAPI = new DragonflyAPI();